<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[寒桥]]></title>
  <subtitle><![CDATA[iOS工程师、前端工程师]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hanqiao8866.github.io/"/>
  <updated>2017-06-25T19:04:08.000Z</updated>
  <id>http://hanqiao8866.github.io/</id>
  
  <author>
    <name><![CDATA[谢涛]]></name>
    <email><![CDATA[hanqiao6666@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[React官方文档翻译 - JSX简介]]></title>
    <link href="http://hanqiao8866.github.io/2017/06/26/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-JSX%E7%AE%80%E4%BB%8B/"/>
    <id>http://hanqiao8866.github.io/2017/06/26/React官方文档翻译-JSX简介/</id>
    <published>2017-06-25T19:03:01.000Z</published>
    <updated>2017-06-25T19:04:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h4><p>下面是一个变量声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</div></pre></td></tr></table></figure>
<p>这个标记语法（tag syntax）既不是字符串也不是HTML。</p>
<p>这种语法叫做<code>JSX</code>，它是JavaScript的一个语法扩展。我们建议在React中使用这种语法来描述UI。JSX看起来像是一种模板语言，但它有JavaScript的所有功能。</p>
<p>JSX提供React的“元素”。我们将在下一章节中探讨在DOM中的渲染。下边将会介绍一些JSX的基本用法。</p>
<p><strong>在JSX中嵌入表达式</strong></p>
<p>你可以在JSX中嵌入任何JavaScript表达式，将代码包裹在大括号中。</p>
<p>比如<code>2 + 2</code>,<code>user.firstName</code>,<code>formatName(user)</code>都是有效的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function formatName(user) &#123;</div><div class="line">  return user.firstName + &apos; &apos; + user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const user = &#123;</div><div class="line">  firstName: &apos;Harper&apos;,</div><div class="line">  lastName: &apos;Perez&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const element = (</div><div class="line">  &lt;h1&gt;</div><div class="line">    Hello, &#123;formatName(user)&#125;!</div><div class="line">  &lt;/h1&gt;</div><div class="line">);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/PGEjdG?editors=0010" target="_blank" rel="external">在CodePen中试一下</a></p>
<p>为了读起来方便，我们将JSX分到多行中，尽管这不是必须的，但是当这样做时，我们还建议包裹在括号中来避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="external">自动分号automatic semicolon insertion</a>的陷阱。</p>
<p><strong>JSX也是一个表达式</strong></p>
<p>编译后，JSX表达式成为常规的JavaScript对象。这就意味着你可以在if语句，for循环中使用JSX，将JSX赋给变量，作为参数接收，从函数中返回等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function getGreeting(user) &#123;</div><div class="line">  if (user) &#123;</div><div class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</div><div class="line">  &#125;</div><div class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>JSX指定属性</strong></p>
<p>你可以在指定字符串中使用引号作为属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</div></pre></td></tr></table></figure>
<p>你也可以用花括号将JavaScript表达式嵌到一个属性中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</div></pre></td></tr></table></figure>
<p>当你在嵌入嵌入JavaScript表达式的时候记得使用花括号，不能使用引号，不然的话JSX会将其当做字符串来处理。</p>
<p><strong>Specifying Children with JSX</strong></p>
<p>如果标签是空的，可以像XML那样用<code>/&gt;</code>来关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</div></pre></td></tr></table></figure>
<p>JSX标签也可以包含子元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const element = (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</div><div class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>因为JSX的语法和HTML的语法很想。React DOM属性使用小驼峰命名。比如在JSX中<code>class</code>变成<code>className</code>，<code>tabindex</code>变成<code>tabIndex</code></p>
</blockquote>
<p><strong>JSX可以防止注入攻击</strong></p>
<p>JSX中嵌入用户输入是安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const title = response.potentiallyMaliciousInput;</div><div class="line">// This is safe:</div><div class="line">const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</div></pre></td></tr></table></figure>
<p>默认情况下，React DOM escapes any values embedded in JSX before rendering them. 因此在你的应用中不能注入任何东西。所有的都在渲染之前转换成了字符串。这个可以防止你受到<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XSS (cross-site-scripting) 攻击</a>。</p>
<p><strong>JSX Represents Objects</strong></p>
<p>Babel编译JSX，调用React.createElement()方法，下边这两个例子是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const element = (</div><div class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</div><div class="line">    Hello, world!</div><div class="line">  &lt;/h1&gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const element = React.createElement(</div><div class="line">  &apos;h1&apos;,</div><div class="line">  &#123;className: &apos;greeting&apos;&#125;,</div><div class="line">  &apos;Hello, world!&apos;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>React.createElement()执行检查使得你的代码没有错误，实质上它创建了一个像这样的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Note: this structure is simplified</div><div class="line">const element = &#123;</div><div class="line">  type: &apos;h1&apos;,</div><div class="line">  props: &#123;</div><div class="line">    className: &apos;greeting&apos;,</div><div class="line">    children: &apos;Hello, world&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些对象被称为“React元素”。你可以认为他们是你想在屏幕中看到的东西的描述。React读取这些对象，使用他们构造DOM并保持更新。</p>
<p>我们酱紫啊下一章节中探讨将React元素渲染到DOM中</p>
<blockquote>
<p>提示：<br>我们建议使用支持Babel语法的编辑器，这样ES6和JSX代码都可以高亮显示。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h4><p>下面是一个变量声明：</p>
<figure class="highlight plain"><table><tr>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[React官方文档翻译 - Hello World]]></title>
    <link href="http://hanqiao8866.github.io/2017/06/26/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Hello-World/"/>
    <id>http://hanqiao8866.github.io/2017/06/26/React官方文档翻译-Hello-World/</id>
    <published>2017-06-25T19:02:49.000Z</published>
    <updated>2017-06-25T19:03:51.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>最简单的开始使用React是在CodePen中使用<a href="http://codepen.io/gaearon/pen/ZpvBNJ?editors=0010" target="_blank" rel="external">Hello World示例代码</a>。你不需要安装任何东西，只需要打开连接进入一个面板中想示例代码中写的那样改写就行。如果你更愿意使用本地开发环境进行编写，可以查看一下<a href="http://javacheng.oschina.io/react/docs/installation.html" target="_blank" rel="external">安装</a>章节的介绍。</p>
<p>最简单的React代码就像这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;h1&gt;Hello, world!&lt;/h1&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这句代码在浏览器中渲染出“Hello World”。</p>
<p>接下来的章节中将逐渐为你介绍如何使用React。我们将会在React应用中尝试构建代码块，元素和组件。一旦你掌握了它们，你可以用小的可重用的组件创作出更将复杂的应用。</p>
<p><strong>JavaScript指南</strong></p>
<p>React是一个JavaScript库，我们假设你已经理解JavaScript语言。如果你觉得掌握还不是很牢靠，我们建议你看一下<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="external">梳理JavaScript知识点</a>的教程。</p>
<p>我们在示例中也会用到一些ES6的语法。我们会尽量少用，毕竟它还是很新的语法，但我们仍然鼓励你熟悉<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">类</a>、<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="external">模板字面量</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">let</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="external">const</a>语句。你可以使用<a href="http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact&amp;experimental=false&amp;loose=false&amp;spec=false&amp;code=const%20element%20%3D%20%3Ch1%3EHello%2C%20world!%3C%2Fh1%3E%3B%0Aconst%20container%20%3D%20document.getElementById(%27root%27" target="_blank" rel="external">Bable REPL</a>%3B%0AReactDOM.render(element%2C%20container)%3B%0A)去检查ES6代码的编译。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>最简单的开始使用React是在CodePen中使用<a href="]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[React官方文档翻译 - 安装]]></title>
    <link href="http://hanqiao8866.github.io/2017/06/26/React%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%AE%89%E8%A3%85/"/>
    <id>http://hanqiao8866.github.io/2017/06/26/React官方文档翻译-安装/</id>
    <published>2017-06-25T19:02:34.000Z</published>
    <updated>2017-06-25T19:03:28.000Z</updated>
    <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>React使用起来很灵活并且可以用在各种项目中。你可以用React创建一个新的应用，你也可以将它引入到一个已经存在的项目中并且不用改写之前的代码库</p>
<ul>
<li>尝试React</li>
</ul>
<p>如果你只是对React感兴趣想简单的使用的话，可以使用CodePen.你不需要安装任何东西，只需要在CodePen中修改代码看看它是否得到你要的结果。</p>
<p>如果你更喜欢使用自己的文本编辑器，你可以下载<br><a href="http://javacheng.oschina.io/react/downloads/single-file-example.html" target="_blank" rel="external">download this HTML file</a>,然后编辑它，在本地浏览器中进行查看。它需要在运行时进行代码转换，因此不要在生产环境中使用。</p>
<p>如果你想在一个完整的项目中使用它，有两种方式可以开始你的React之旅：创建一个新应用，添加React到已有的项目中。</p>
<ul>
<li>创建新应用</li>
</ul>
<p>创建新的应用是开始构建一个新的程序最好的方式，它为你创建了开发环境，以便你可以使用最新的JavaScript特性，提供一个良好的开发体验，同时可以优化(optimizes)你生产环境下的应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line">create-react-app my-app</div><div class="line"></div><div class="line">cd my-app</div><div class="line">npm start</div></pre></td></tr></table></figure>
<p>创建的新应用不处理后端逻辑(backend logic)和数据库，只是提供一种创建前端的方式，因此不影响你使用的后台。React使用Babel这样的构建工具，在hood下webpack，但没有任何配置。</p>
<p>当你准备部署（deploy）到生产环境的时候，运行<code>npm run build</code>将在<code>build</code>文件夹下构建一个优化的项目。你也可以在<a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="external">from its ReadMe</a>和<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="external">User Guide</a>下学到更多创建新的React的知识。</p>
<ul>
<li>添加React到已有项目中</li>
</ul>
<p>当你开始使用React的时候你并不需要重写你的项目。</p>
<p>我们建议你增加React到你应用程序作为其中的一小部分，比如一个小部件，你可以通过用例看是否执行。</p>
<p>然而React可以在没有构建管道（build pipeline）的情况下<a href="http://javacheng.oschina.io/react/docs/react-without-es6.html" target="_blank" rel="external">使用</a>，我们建议你进行相关的设置这样会使得你更高效。一个现代的构建管道方式一般包含以下几个部分：</p>
<p>（1）一个包管理器，如<a href="https://yarnpkg.com/" target="_blank" rel="external">Yarn</a>或者<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>。它允许你利用第三方包管理巨大的生态系统，更方便的安装和更新它们</p>
<p>（2）一个bundler，如<a href="https://webpack.js.org/" target="_blank" rel="external">webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>。它允许你编写模块代码并打包到更小的包中，从而优化加载时间。</p>
<p>（3）一个<a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>编译器。它允许你在就得浏览器中编写更现代化的JavaScript代码。</p>
<p><strong>安装React</strong><br>我们建议使用Yarn或者npm来管理前端使用到的各种依赖。如果之前没有使用过包管理，可以从<a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="external">Yarn文档</a>开始。</p>
<p>使用Yarn安装React：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yarn init</div><div class="line">yarn add react react-dom</div></pre></td></tr></table></figure>
<p>使用npm安装React</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm init</div><div class="line">npm install --save react react-dom</div></pre></td></tr></table></figure>
<p>Yarn和npm都从<a href="http://npmjs.com/" target="_blank" rel="external">npm registry</a>下载包。</p>
<p><strong>启用ES6和JSX</strong></p>
<p>我们建议使用webpack或者Browserify来打包，这样的话你可以使用模块代码打包到更小的包中，优化加载时间</p>
<p>最小对的React例子就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import ReactDOM from &apos;react-dom&apos;;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;h1&gt;Hello, world!&lt;/h1&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这段代码显示到DOM元素中，使用id为root，所以你早在你的HTML文件中使用<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>。</p>
<p>类似的，你可以在你已存在的项目中DOM元素中渲染一个用其他JavaScript的UI库的React组件。</p>
<p><strong>开发环境版本和生产环境版本</strong></p>
<p>默认情况下，React包含很多有用的警告。这些警告在开发环境版本中非常有用。但是，这些警告会使得React体积变大，运行速度降低，因此当你在部署应用程序的时候要使用生产环境版本。</p>
<p>（1）Brunch<br>使用<code>Brunch</code>创建一个优化的生产环境版本，只需要在构建命令中使用<code>-p</code>标签。可以查看<a href="http://brunch.io/docs/commands" target="_blank" rel="external">Brunch文档</a>查看更多详细信息。</p>
<p>（2）Browserify<br>使用环境变量<code>NODE_ENV</code>设置生产环境版本来运行Browserify，构建代码最后一步使用<a href="https://github.com/mishoo/UglifyJS" target="_blank" rel="external">UglifyJS</a>来剥离开发环境下的代码。</p>
<p>（3）Rollup<br>使用<a href="https://github.com/rollup/rollup-plugin-replace" target="_blank" rel="external">rollup-plugin-replace</a>和<a href="https://github.com/rollup/rollup-plugin-commonjs" target="_blank" rel="external">rollup-plugin-commonjs</a>来移除开发环境版本中的代码。完整的设置代码可以查看<a href="https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0" target="_blank" rel="external">See this gist</a>。</p>
<p>（4）Webpack<br>在Webpack配置将<code>DefinePlugin</code>和<code>UglifyJsPlugin</code>配置到生产环境版本中，具体文档可以查看<a href="https://webpack.js.org/guides/production-build/" target="_blank" rel="external">Webpack Guider</a></p>
<p><strong>使用CDN</strong><br>如果你不想使用npm来管理客户端包，在<code>dist</code>文件夹中的<code>react</code>和<code>react-dom</code>npm包也提供了相应的单文件发布，这个是托管在CDN上的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/react@15/dist/react.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/react-dom@15/dist/react-dom.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>上面的版本只适用于开发环境版本，不适用于生产环境版本。简化和优化React的生产环境版本可以使用下边的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/react@15/dist/react.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://unpkg.com/react-dom@15/dist/react-dom.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>加载一个特定版本的<code>react</code>和<code>react-dom</code>取代15版本号。如果你使用<code>Bower</code>，React可以通过<code>react</code>包来提供。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>React使用起来很灵活并且可以用在各种项目中。你可以用React创建一个新的应用，你也可以将它引入到一个已经存在的项目中并且不用改写之前的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo使用总结]]></title>
    <link href="http://hanqiao8866.github.io/2017/06/25/Hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://hanqiao8866.github.io/2017/06/25/Hexo使用总结/</id>
    <published>2017-06-24T16:44:54.000Z</published>
    <updated>2017-06-24T19:45:45.000Z</updated>
    <content type="html"><![CDATA[<h4 id="创建GitHub上代码仓库"><a href="#创建GitHub上代码仓库" class="headerlink" title="创建GitHub上代码仓库"></a>创建GitHub上代码仓库</h4><p><img src="http://upload-images.jianshu.io/upload_images/291600-7cec7b9f28359ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在仓库名字输入框中输入：Github昵称.github.io</p>
<h4 id="生成添加秘钥"><a href="#生成添加秘钥" class="headerlink" title="生成添加秘钥"></a>生成添加秘钥</h4><p>在终端（Terminal）输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</div></pre></td></tr></table></figure>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><h4 id="安装配置hexo"><a href="#安装配置hexo" class="headerlink" title="安装配置hexo"></a>安装配置hexo</h4><ul>
<li>定位博客本地路径</li>
<li>下载安装hexo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<ul>
<li>安装好hexo以后，在终端输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo</div></pre></td></tr></table></figure>
<ul>
<li>初始化博客</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字</div><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">// 进入博客文件夹，&lt;folder&gt;为文件夹的名称</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<h4 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site</div><div class="line">title: # The title of your website</div><div class="line">subtitle: # The subtitle of your website</div><div class="line">description: # The description of your website</div><div class="line">author: # Your name</div><div class="line">language: # The language of your website</div><div class="line">timezone: </div><div class="line"></div><div class="line"># URL</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: http://yoursite.com/child</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div><div class="line"></div><div class="line"># Directory</div><div class="line">source_dir: source</div><div class="line">public_dir: public</div><div class="line">tag_dir: tags</div><div class="line">archive_dir: archives</div><div class="line">category_dir: categories</div><div class="line">code_dir: downloads/code</div><div class="line">i18n_dir: :lang</div><div class="line">skip_render:</div><div class="line"></div><div class="line"># Writing</div><div class="line">new_post_name: :title.md # File name of new posts</div><div class="line">default_layout: post</div><div class="line">titlecase: false # Transform title into titlecase</div><div class="line">external_link: true # Open external links in new tab</div><div class="line">filename_case: 0</div><div class="line">render_drafts: false</div><div class="line">post_asset_folder: false</div><div class="line">relative_link: false</div><div class="line">future: true</div><div class="line">highlight:</div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"></div><div class="line"># Date / Time format</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD</div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination</div><div class="line">## Set per_page to 0 to disable pagination</div><div class="line">per_page: 10</div><div class="line">pagination_dir: page</div><div class="line"></div><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: landscape</div><div class="line"></div><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type:</div></pre></td></tr></table></figure>
<h4 id="部属配置"><a href="#部属配置" class="headerlink" title="部属配置"></a>部属配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/hanqiao8866/hanqiao8866.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<h4 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h4><p>hexo new “文章标题”</p>
<h4 id="执行更新"><a href="#执行更新" class="headerlink" title="执行更新"></a>执行更新</h4><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>hexo s</p>
<p>// 清理缓存<br>hexo clean<br>// 生成文件<br>hexo generate<br>// 部署(到远程Github上)<br>hexo deploy<br>// 部署(到本地)<br>hexo server</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul>
<li>Deployer not found: git<br>在终端执行命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>然后继续执行hexo deploye指令进行部署。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="创建GitHub上代码仓库"><a href="#创建GitHub上代码仓库" class="headerlink" title="创建GitHub上代码仓库"></a>创建GitHub上代码仓库</h4><p><img src="http://upload-im]]>
    </summary>
    
      <category term="hexo使用" scheme="http://hanqiao8866.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift语法（语法基础）]]></title>
    <link href="http://hanqiao8866.github.io/2017/06/25/Swift%20Tour%20Learn%20(%E4%B8%80)%20--%20Swift%20%E8%AF%AD%E6%B3%95%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://hanqiao8866.github.io/2017/06/25/Swift Tour Learn (一) -- Swift 语法（语法基础）/</id>
    <published>2017-06-24T16:44:54.000Z</published>
    <updated>2017-06-24T19:45:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift语法（语法基础）"><a href="#Swift语法（语法基础）" class="headerlink" title="Swift语法（语法基础）"></a>Swift语法（语法基础）</h1><h4 id="本章将会介绍"><a href="#本章将会介绍" class="headerlink" title="本章将会介绍"></a>本章将会介绍</h4><blockquote>
<p>什么是Swift<br>基础部分（The Basic）</p>
</blockquote>
<h4 id="什么是Swift"><a href="#什么是Swift" class="headerlink" title="什么是Swift"></a>什么是Swift</h4><p>Swift 是一种新的编程语言，用于编写 iOS，macOS，watchOS 和 tvOS 的应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。 Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的系统编程语言。它支持代码预览(playgrounds)，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，macOS，watchOS 和 tvOS 应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
<h4 id="基础部分（The-Basic）"><a href="#基础部分（The-Basic）" class="headerlink" title="基础部分（The Basic）"></a>基础部分（The Basic）</h4><p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code>表示整型值； <code>Double</code> 和 <code>Float</code> 表示浮点型值； <code>Bool</code> 是布尔型值；<code>String</code> 是文本型数据。 Swift 还提供了三个基本的集合类型，<code>Array</code> ，<code>Set</code> 和 <code>Dictionary</code>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>Swift 还增加了 Objective-C 中没有的高阶数据类型比如<code>元组（Tuple）</code>。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了<code>可选（Optional）</code>类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<h5 id="1-常量和变量"><a href="#1-常量和变量" class="headerlink" title="1.常量和变量"></a>1.常量和变量</h5><ul>
<li>常量的值一旦设定就不能改变，而变量的值可以随意更改。</li>
<li>常量和变量必须在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。</li>
<li>可以在一行中声明多个常量或者多个变量，用逗号隔开：<code>var x = 0.0, y = 0.0, z = 0.0</code></li>
</ul>
<h5 id="2-类型标注（type-annotation）"><a href="#2-类型标注（type-annotation）" class="headerlink" title="2.类型标注（type annotation）"></a>2.类型标注（type annotation）</h5><p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。</p>
<ul>
<li><p>声明中的冒号代表着“是…类型”，比如<code>var welcomeMessage: String</code>,可以被理解为：“声明一个类型为 String ，名字为 welcomeMessage 的变量。”</p>
</li>
<li><p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：<code>var red, green, blue: Double</code></p>
</li>
</ul>
<blockquote>
<p>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给 welcomeMessage 赋初始值，所以变量 welcomeMessage 的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>
<h5 id="3-常量和变量的命名"><a href="#3-常量和变量的命名" class="headerlink" title="3.常量和变量的命名"></a>3.常量和变量的命名</h5><ul>
<li>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</li>
<li>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</li>
</ul>
<h5 id="4-输出常量和变量"><a href="#4-输出常量和变量" class="headerlink" title="4.输出常量和变量"></a>4.输出常量和变量</h5><p>你可以用<code>print(_:separator:terminator:)</code>函数来输出当前常量或变量的值:<code>separator</code> 和 <code>terminator</code> 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 <code>terminator</code> 参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code>。</p>
<p>Swift 用<code>字符串插值（string interpolation）</code>的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)</div><div class="line">// 输出 &quot;The current value of friendlyWelcome is Bonjour!</div></pre></td></tr></table></figure>
<h5 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h5><ul>
<li>单行注释以双正斜杠（//）作为起始标记</li>
<li>多行注释  <code>/* code */</code></li>
<li>可以使用注释嵌套</li>
</ul>
<h5 id="6-分号"><a href="#6-分号" class="headerlink" title="6.分号"></a>6.分号</h5><p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。但是如果在同一行内写多条独立的语句，那么必须使用分号</p>
<h5 id="7-整数"><a href="#7-整数" class="headerlink" title="7.整数"></a>7.整数</h5><ul>
<li><p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是 <code>Int32</code></p>
</li>
<li><p>可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型</div><div class="line">let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Int</code>整数类型长度与当前平台的原生字长相同：在32位平台上，<code>Int</code> 和 <code>Int32</code> 长度相同。在64位平台上，<code>Int</code> 和 <code>Int64</code> 长度相同。</p>
</li>
<li><p><code>UInt</code>无符号类型 <code>UInt</code>，长度与当前平台的原生字长相同：在32位平台上，<code>UInt</code> 和 <code>UInt32</code> 长度相同。在64位平台上，<code>UInt</code> 和 <code>UInt64</code> 长度相同。</p>
</li>
</ul>
<h5 id="8-浮点数"><a href="#8-浮点数" class="headerlink" title="8.浮点数"></a>8.浮点数</h5><ul>
<li><p>浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li>Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
</li>
<li><p>Double精确度很高，至少有15位数字，而Float只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double。</p>
</li>
</ul>
<h5 id="9-类型安全（type-safe）和类型推断（type-checks）"><a href="#9-类型安全（type-safe）和类型推断（type-checks）" class="headerlink" title="9.类型安全（type safe）和类型推断（type checks）"></a>9.类型安全（type safe）和类型推断（type checks）</h5><p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。</p>
<p>如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 Double：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let pi = 3.14159</div><div class="line">// pi 会被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。<br>如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let anotherPi = 3 + 0.14159</div><div class="line">// anotherPi 会被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>原始值 3 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 Double 类型。</p>
<h5 id="10-数值型字面量"><a href="#10-数值型字面量" class="headerlink" title="10.数值型字面量"></a>10.数值型字面量</h5><p>整数字面量可以被写作：</p>
<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是0b</li>
<li>一个八进制数，前缀是0o</li>
<li>一个十六进制数，前缀是0x</li>
</ul>
<p>下面的所有整数字面量的十进制值都是17:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let decimalInteger = 17</div><div class="line">let binaryInteger = 0b10001       // 二进制的17</div><div class="line">let octalInteger = 0o21           // 八进制的17</div><div class="line">let hexadecimalInteger = 0x11     // 十六进制的17</div></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let paddedDouble = 000123.456</div><div class="line">let oneMillion = 1_000_000</div><div class="line">let justOverOneMillion = 1_000_000.000_000_1</div></pre></td></tr></table></figure>
<h5 id="11-整数转化"><a href="#11-整数转化" class="headerlink" title="11.整数转化"></a>11.整数转化</h5><p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是UInt8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let twoThousand: UInt16 = 2_000</div><div class="line">let one: UInt8 = 1</div><div class="line">let twoThousandAndOne = twoThousand + UInt16(one)</div></pre></td></tr></table></figure>
<p>现在两个数字的类型都是 UInt16，可以进行相加。目标常量 twoThousandAndOne 的类型被推断为 UInt16，因为它是两个 UInt16 值的和。</p>
<p>SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16 有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16。注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。</p>
<h5 id="12-整数和浮点数的转换"><a href="#12-整数和浮点数的转换" class="headerlink" title="12.整数和浮点数的转换"></a>12.整数和浮点数的转换</h5><p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let three = 3</div><div class="line">let pointOneFourOneFiveNine = 0.14159</div><div class="line">let pi = Double(three) + pointOneFourOneFiveNine</div><div class="line">// pi 等于 3.14159，所以被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>这个例子中，常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用 Double 或者 Float 类型来初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let integerPi = Int(pi)</div><div class="line">// integerPi 等于 3，所以被推测为 Int 类型</div></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4，-3.9 会变成 -3。</p>
<h5 id="13-类型别名（type-aliases）"><a href="#13-类型别名（type-aliases）" class="headerlink" title="13.类型别名（type aliases）"></a>13.类型别名（type aliases）</h5><p>就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias AudioSample = UInt16</div></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var maxAmplitudeFound = AudioSample.min</div><div class="line">// maxAmplitudeFound 现在是 0</div></pre></td></tr></table></figure>
<p>本例中，AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0。</p>
<h5 id="14-布尔值（Bool）"><a href="#14-布尔值（Bool）" class="headerlink" title="14.布尔值（Bool）"></a>14.布尔值（Bool）</h5><p>Swift 有一个基本的布尔（Boolean）类型，叫做Bool。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false</p>
<h5 id="15-元组（tuples）"><a href="#15-元组（tuples）" class="headerlink" title="15.元组（tuples）"></a>15.元组（tuples）</h5><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let http404Error = (404, &quot;Not Found&quot;)</div><div class="line">// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</div></pre></td></tr></table></figure>
<p>(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。<br>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 (Int, Int, Int) 或者 (String, Bool) 或者其他任何你想要的组合的元组。你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let (statusCode, statusMessage) = http404Error</div><div class="line">print(&quot;The status code is \(statusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div><div class="line">print(&quot;The status message is \(statusMessage)&quot;)</div><div class="line">// 输出 &quot;The status message is Not Found&quot;</div></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let (justTheStatusCode, _) = http404Error</div><div class="line">print(&quot;The status code is \(justTheStatusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(&quot;The status code is \(http404Error.0)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div><div class="line">print(&quot;The status message is \(http404Error.1)&quot;)</div><div class="line">// 输出 &quot;The status message is Not Found&quot;</div></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let http200Status = (statusCode: 200, description: &quot;OK&quot;)</div></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(&quot;The status code is \(http200Status.statusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 200&quot;</div><div class="line">print(&quot;The status message is \(http200Status.description)&quot;)</div><div class="line">// 输出 &quot;The status message is OK&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。</p>
</blockquote>
<h5 id="16-可选类型（Optionals）"><a href="#16-可选类型（Optionals）" class="headerlink" title="16.可选类型（Optionals）"></a>16.可选类型（Optionals）</h5><p>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于x</li>
<li>没有值</li>
</ul>
<blockquote>
<p>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>Swift 的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 “123” 可以被转换成数字 123 ，但是字符串 “hello, world” 不行。<br>下面的例子使用这种构造器来尝试将一个 String 转换成 Int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let possibleNumber = &quot;123&quot;</div><div class="line">let convertedNumber = Int(possibleNumber)</div><div class="line">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</div></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。一个可选的 Int 被写作 Int? 而不是 Int。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值比如 Bool 值或者 String 值。只能是 Int 或者什么都没有。）</p>
<h5 id="17-nil"><a href="#17-nil" class="headerlink" title="17.nil"></a>17.nil</h5><p>你可以给可选变量赋值为nil来表示它没有值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var serverResponseCode: Int? = 404</div><div class="line">// serverResponseCode 包含一个可选的 Int 值 404</div><div class="line">serverResponseCode = nil</div><div class="line">// serverResponseCode 现在不包含值</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var surveyAnswer: String?</div><div class="line">// surveyAnswer 被自动设置为 nil</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
</blockquote>
<h5 id="18-if语句以及强制解析"><a href="#18-if语句以及强制解析" class="headerlink" title="18.if语句以及强制解析"></a>18.if语句以及强制解析</h5><p>你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不等”(!=)来执行比较。</p>
<p>如果可选类型有值，它将不等于 nil：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if convertedNumber != nil &#123;</div><div class="line">    print(&quot;convertedNumber contains some integer value.&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;convertedNumber contains some integer value.&quot;</div></pre></td></tr></table></figure>
<h5 id="19-可选绑定（optional-binding）"><a href="#19-可选绑定（optional-binding）" class="headerlink" title="19.可选绑定（optional binding）"></a>19.可选绑定（optional binding）</h5><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。</p>
<p>你可以像上面这样使用可选绑定来重写 possibleNumber 这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if let actualNumber = Int(possibleNumber) &#123;</div><div class="line">    print(&quot;\&apos;\(possibleNumber)\&apos; has an integer value of \(actualNumber)&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;\&apos;\(possibleNumber)\&apos; could not be converted to an integer&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;&apos;123&apos; has an integer value of 123&quot;</div></pre></td></tr></table></figure>
<p>这段代码可以被理解为：“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值，你可以改成 if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条件语句来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;</div><div class="line">    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</div><div class="line"></div><div class="line">if let firstNumber = Int(&quot;4&quot;) &#123;</div><div class="line">    if let secondNumber = Int(&quot;42&quot;) &#123;</div><div class="line">        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;</div><div class="line">            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意： 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中(body)中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值，</p>
</blockquote>
<h5 id="20-隐式解析可选类型（implicitly-unwrapped-optionals）"><a href="#20-隐式解析可选类型（implicitly-unwrapped-optionals）" class="headerlink" title="20.隐式解析可选类型（implicitly unwrapped optionals）"></a>20.隐式解析可选类型（implicitly unwrapped optionals）</h5><p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let possibleString: String? = &quot;An optional string.&quot;</div><div class="line">let forcedString: String = possibleString! // 需要感叹号来获取值</div><div class="line"></div><div class="line">let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;</div><div class="line">let implicitString: String = assumedString  // 不需要感叹号</div></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。<br>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if assumedString != nil &#123;</div><div class="line">    print(assumedString)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;An implicitly unwrapped optional string.&quot;</div></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if let definiteString = assumedString &#123;</div><div class="line">    print(definiteString)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;An implicitly unwrapped optional string.&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>
</blockquote>
<h5 id="21-错误处理（error-handling）"><a href="#21-错误处理（error-handling）" class="headerlink" title="21.错误处理（error handling）"></a>21.错误处理（error handling）</h5><p>你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func canThrowAnError() throws &#123;</div><div class="line">    // 这个函数有可能抛出错误</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加throws关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try canThrowAnError()</div><div class="line">    // 没有错误消息抛出</div><div class="line">&#125; catch &#123;</div><div class="line">    // 有一个错误消息抛出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个do语句创建了一个新的包含作用域,使得错误能被传播到一个或多个catch从句。<br>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func makeASandwich() throws &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">    try makeASandwich()</div><div class="line">    eatASandwich()</div><div class="line">&#125; catch SandwichError.outOfCleanDishes &#123;</div><div class="line">    washDishes()</div><div class="line">&#125; catch SandwichError.missingIngredients(let ingredients) &#123;</div><div class="line">    buyGroceries(ingredients)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此例中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。</p>
<p>如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。</p>
<h5 id="22-断言（assertion）"><a href="#22-断言（assertion）" class="headerlink" title="22.断言（assertion）"></a>22.断言（assertion）</h5><p>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个 断言（assertion） 来结束代码运行并通过调试来找到值缺失的原因。</p>
<p>可以使用全局 assert(<em>:</em>:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let age = -3</div><div class="line">assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)</div><div class="line">// 因为 age &lt; 0，所以断言会触发</div></pre></td></tr></table></figure>
<p>如果不需要断言信息，可以省略，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(age &gt;= 0)</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。</p>
</blockquote>
<p>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是 nil，但是后面的代码运行需要一个非 nil 值。</li>
</ul>
<blockquote>
<p>注意：<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift语法（语法基础）"><a href="#Swift语法（语法基础）" class="headerlink" title="Swift语法（语法基础）"></a>Swift语法（语法基础）</h1><h4 id="本章将会介绍"><a href="#本章将]]>
    </summary>
    
      <category term="swift" scheme="http://hanqiao8866.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
