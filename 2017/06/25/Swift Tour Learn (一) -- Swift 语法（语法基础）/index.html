<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="iOS工程师、前端工程师">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="寒桥" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        寒桥的博客
        
    </title>

    <link rel="canonical" href="http://hanqiao8866.github.io/2017/06/25/Swift Tour Learn (一) -- Swift 语法（语法基础）/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('null')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    寒桥
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/About/">About</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/Category/">Category</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1></h1>
                    
                    <span class="meta">
                         作者 谢涛
                        <span>
                          日期 2017-06-25
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="Swift语法（语法基础）"><a href="#Swift语法（语法基础）" class="headerlink" title="Swift语法（语法基础）"></a>Swift语法（语法基础）</h1><h4 id="本章将会介绍"><a href="#本章将会介绍" class="headerlink" title="本章将会介绍"></a>本章将会介绍</h4><blockquote>
<p>什么是Swift<br>基础部分（The Basic）</p>
</blockquote>
<h4 id="什么是Swift"><a href="#什么是Swift" class="headerlink" title="什么是Swift"></a>什么是Swift</h4><p>Swift 是一种新的编程语言，用于编写 iOS，macOS，watchOS 和 tvOS 的应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。 Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的系统编程语言。它支持代码预览(playgrounds)，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，macOS，watchOS 和 tvOS 应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
<h4 id="基础部分（The-Basic）"><a href="#基础部分（The-Basic）" class="headerlink" title="基础部分（The Basic）"></a>基础部分（The Basic）</h4><p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code>表示整型值； <code>Double</code> 和 <code>Float</code> 表示浮点型值； <code>Bool</code> 是布尔型值；<code>String</code> 是文本型数据。 Swift 还提供了三个基本的集合类型，<code>Array</code> ，<code>Set</code> 和 <code>Dictionary</code>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>Swift 还增加了 Objective-C 中没有的高阶数据类型比如<code>元组（Tuple）</code>。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了<code>可选（Optional）</code>类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<h5 id="1-常量和变量"><a href="#1-常量和变量" class="headerlink" title="1.常量和变量"></a>1.常量和变量</h5><ul>
<li>常量的值一旦设定就不能改变，而变量的值可以随意更改。</li>
<li>常量和变量必须在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。</li>
<li>可以在一行中声明多个常量或者多个变量，用逗号隔开：<code>var x = 0.0, y = 0.0, z = 0.0</code></li>
</ul>
<h5 id="2-类型标注（type-annotation）"><a href="#2-类型标注（type-annotation）" class="headerlink" title="2.类型标注（type annotation）"></a>2.类型标注（type annotation）</h5><p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。</p>
<ul>
<li><p>声明中的冒号代表着“是…类型”，比如<code>var welcomeMessage: String</code>,可以被理解为：“声明一个类型为 String ，名字为 welcomeMessage 的变量。”</p>
</li>
<li><p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：<code>var red, green, blue: Double</code></p>
</li>
</ul>
<blockquote>
<p>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给 welcomeMessage 赋初始值，所以变量 welcomeMessage 的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>
<h5 id="3-常量和变量的命名"><a href="#3-常量和变量的命名" class="headerlink" title="3.常量和变量的命名"></a>3.常量和变量的命名</h5><ul>
<li>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</li>
<li>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</li>
</ul>
<h5 id="4-输出常量和变量"><a href="#4-输出常量和变量" class="headerlink" title="4.输出常量和变量"></a>4.输出常量和变量</h5><p>你可以用<code>print(_:separator:terminator:)</code>函数来输出当前常量或变量的值:<code>separator</code> 和 <code>terminator</code> 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 <code>terminator</code> 参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code>。</p>
<p>Swift 用<code>字符串插值（string interpolation）</code>的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)</div><div class="line">// 输出 &quot;The current value of friendlyWelcome is Bonjour!</div></pre></td></tr></table></figure>
<h5 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h5><ul>
<li>单行注释以双正斜杠（//）作为起始标记</li>
<li>多行注释  <code>/* code */</code></li>
<li>可以使用注释嵌套</li>
</ul>
<h5 id="6-分号"><a href="#6-分号" class="headerlink" title="6.分号"></a>6.分号</h5><p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。但是如果在同一行内写多条独立的语句，那么必须使用分号</p>
<h5 id="7-整数"><a href="#7-整数" class="headerlink" title="7.整数"></a>7.整数</h5><ul>
<li><p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是 <code>Int32</code></p>
</li>
<li><p>可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型</div><div class="line">let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Int</code>整数类型长度与当前平台的原生字长相同：在32位平台上，<code>Int</code> 和 <code>Int32</code> 长度相同。在64位平台上，<code>Int</code> 和 <code>Int64</code> 长度相同。</p>
</li>
<li><p><code>UInt</code>无符号类型 <code>UInt</code>，长度与当前平台的原生字长相同：在32位平台上，<code>UInt</code> 和 <code>UInt32</code> 长度相同。在64位平台上，<code>UInt</code> 和 <code>UInt64</code> 长度相同。</p>
</li>
</ul>
<h5 id="8-浮点数"><a href="#8-浮点数" class="headerlink" title="8.浮点数"></a>8.浮点数</h5><ul>
<li><p>浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li>Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
</li>
<li><p>Double精确度很高，至少有15位数字，而Float只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double。</p>
</li>
</ul>
<h5 id="9-类型安全（type-safe）和类型推断（type-checks）"><a href="#9-类型安全（type-safe）和类型推断（type-checks）" class="headerlink" title="9.类型安全（type safe）和类型推断（type checks）"></a>9.类型安全（type safe）和类型推断（type checks）</h5><p>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。</p>
<p>如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 Double：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let pi = 3.14159</div><div class="line">// pi 会被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。<br>如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let anotherPi = 3 + 0.14159</div><div class="line">// anotherPi 会被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>原始值 3 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 Double 类型。</p>
<h5 id="10-数值型字面量"><a href="#10-数值型字面量" class="headerlink" title="10.数值型字面量"></a>10.数值型字面量</h5><p>整数字面量可以被写作：</p>
<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是0b</li>
<li>一个八进制数，前缀是0o</li>
<li>一个十六进制数，前缀是0x</li>
</ul>
<p>下面的所有整数字面量的十进制值都是17:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let decimalInteger = 17</div><div class="line">let binaryInteger = 0b10001       // 二进制的17</div><div class="line">let octalInteger = 0o21           // 八进制的17</div><div class="line">let hexadecimalInteger = 0x11     // 十六进制的17</div></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let paddedDouble = 000123.456</div><div class="line">let oneMillion = 1_000_000</div><div class="line">let justOverOneMillion = 1_000_000.000_000_1</div></pre></td></tr></table></figure>
<h5 id="11-整数转化"><a href="#11-整数转化" class="headerlink" title="11.整数转化"></a>11.整数转化</h5><p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是UInt8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let twoThousand: UInt16 = 2_000</div><div class="line">let one: UInt8 = 1</div><div class="line">let twoThousandAndOne = twoThousand + UInt16(one)</div></pre></td></tr></table></figure>
<p>现在两个数字的类型都是 UInt16，可以进行相加。目标常量 twoThousandAndOne 的类型被推断为 UInt16，因为它是两个 UInt16 值的和。</p>
<p>SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16 有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16。注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。</p>
<h5 id="12-整数和浮点数的转换"><a href="#12-整数和浮点数的转换" class="headerlink" title="12.整数和浮点数的转换"></a>12.整数和浮点数的转换</h5><p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let three = 3</div><div class="line">let pointOneFourOneFiveNine = 0.14159</div><div class="line">let pi = Double(three) + pointOneFourOneFiveNine</div><div class="line">// pi 等于 3.14159，所以被推测为 Double 类型</div></pre></td></tr></table></figure>
<p>这个例子中，常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用 Double 或者 Float 类型来初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let integerPi = Int(pi)</div><div class="line">// integerPi 等于 3，所以被推测为 Int 类型</div></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4，-3.9 会变成 -3。</p>
<h5 id="13-类型别名（type-aliases）"><a href="#13-类型别名（type-aliases）" class="headerlink" title="13.类型别名（type aliases）"></a>13.类型别名（type aliases）</h5><p>就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias AudioSample = UInt16</div></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var maxAmplitudeFound = AudioSample.min</div><div class="line">// maxAmplitudeFound 现在是 0</div></pre></td></tr></table></figure>
<p>本例中，AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0。</p>
<h5 id="14-布尔值（Bool）"><a href="#14-布尔值（Bool）" class="headerlink" title="14.布尔值（Bool）"></a>14.布尔值（Bool）</h5><p>Swift 有一个基本的布尔（Boolean）类型，叫做Bool。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false</p>
<h5 id="15-元组（tuples）"><a href="#15-元组（tuples）" class="headerlink" title="15.元组（tuples）"></a>15.元组（tuples）</h5><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let http404Error = (404, &quot;Not Found&quot;)</div><div class="line">// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</div></pre></td></tr></table></figure>
<p>(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。<br>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 (Int, Int, Int) 或者 (String, Bool) 或者其他任何你想要的组合的元组。你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let (statusCode, statusMessage) = http404Error</div><div class="line">print(&quot;The status code is \(statusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div><div class="line">print(&quot;The status message is \(statusMessage)&quot;)</div><div class="line">// 输出 &quot;The status message is Not Found&quot;</div></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let (justTheStatusCode, _) = http404Error</div><div class="line">print(&quot;The status code is \(justTheStatusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(&quot;The status code is \(http404Error.0)&quot;)</div><div class="line">// 输出 &quot;The status code is 404&quot;</div><div class="line">print(&quot;The status message is \(http404Error.1)&quot;)</div><div class="line">// 输出 &quot;The status message is Not Found&quot;</div></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let http200Status = (statusCode: 200, description: &quot;OK&quot;)</div></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(&quot;The status code is \(http200Status.statusCode)&quot;)</div><div class="line">// 输出 &quot;The status code is 200&quot;</div><div class="line">print(&quot;The status message is \(http200Status.description)&quot;)</div><div class="line">// 输出 &quot;The status message is OK&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。</p>
</blockquote>
<h5 id="16-可选类型（Optionals）"><a href="#16-可选类型（Optionals）" class="headerlink" title="16.可选类型（Optionals）"></a>16.可选类型（Optionals）</h5><p>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于x</li>
<li>没有值</li>
</ul>
<blockquote>
<p>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>Swift 的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 “123” 可以被转换成数字 123 ，但是字符串 “hello, world” 不行。<br>下面的例子使用这种构造器来尝试将一个 String 转换成 Int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let possibleNumber = &quot;123&quot;</div><div class="line">let convertedNumber = Int(possibleNumber)</div><div class="line">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</div></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。一个可选的 Int 被写作 Int? 而不是 Int。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值比如 Bool 值或者 String 值。只能是 Int 或者什么都没有。）</p>
<h5 id="17-nil"><a href="#17-nil" class="headerlink" title="17.nil"></a>17.nil</h5><p>你可以给可选变量赋值为nil来表示它没有值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var serverResponseCode: Int? = 404</div><div class="line">// serverResponseCode 包含一个可选的 Int 值 404</div><div class="line">serverResponseCode = nil</div><div class="line">// serverResponseCode 现在不包含值</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var surveyAnswer: String?</div><div class="line">// surveyAnswer 被自动设置为 nil</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
</blockquote>
<h5 id="18-if语句以及强制解析"><a href="#18-if语句以及强制解析" class="headerlink" title="18.if语句以及强制解析"></a>18.if语句以及强制解析</h5><p>你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不等”(!=)来执行比较。</p>
<p>如果可选类型有值，它将不等于 nil：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if convertedNumber != nil &#123;</div><div class="line">    print(&quot;convertedNumber contains some integer value.&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;convertedNumber contains some integer value.&quot;</div></pre></td></tr></table></figure>
<h5 id="19-可选绑定（optional-binding）"><a href="#19-可选绑定（optional-binding）" class="headerlink" title="19.可选绑定（optional binding）"></a>19.可选绑定（optional binding）</h5><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。</p>
<p>你可以像上面这样使用可选绑定来重写 possibleNumber 这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if let actualNumber = Int(possibleNumber) &#123;</div><div class="line">    print(&quot;\&apos;\(possibleNumber)\&apos; has an integer value of \(actualNumber)&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;\&apos;\(possibleNumber)\&apos; could not be converted to an integer&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;&apos;123&apos; has an integer value of 123&quot;</div></pre></td></tr></table></figure>
<p>这段代码可以被理解为：“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值，你可以改成 if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条件语句来处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;</div><div class="line">    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</div><div class="line"></div><div class="line">if let firstNumber = Int(&quot;4&quot;) &#123;</div><div class="line">    if let secondNumber = Int(&quot;42&quot;) &#123;</div><div class="line">        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123;</div><div class="line">            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意： 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中(body)中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值，</p>
</blockquote>
<h5 id="20-隐式解析可选类型（implicitly-unwrapped-optionals）"><a href="#20-隐式解析可选类型（implicitly-unwrapped-optionals）" class="headerlink" title="20.隐式解析可选类型（implicitly unwrapped optionals）"></a>20.隐式解析可选类型（implicitly unwrapped optionals）</h5><p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let possibleString: String? = &quot;An optional string.&quot;</div><div class="line">let forcedString: String = possibleString! // 需要感叹号来获取值</div><div class="line"></div><div class="line">let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;</div><div class="line">let implicitString: String = assumedString  // 不需要感叹号</div></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。<br>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if assumedString != nil &#123;</div><div class="line">    print(assumedString)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;An implicitly unwrapped optional string.&quot;</div></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if let definiteString = assumedString &#123;</div><div class="line">    print(definiteString)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;An implicitly unwrapped optional string.&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>
</blockquote>
<h5 id="21-错误处理（error-handling）"><a href="#21-错误处理（error-handling）" class="headerlink" title="21.错误处理（error handling）"></a>21.错误处理（error handling）</h5><p>你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func canThrowAnError() throws &#123;</div><div class="line">    // 这个函数有可能抛出错误</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加throws关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try canThrowAnError()</div><div class="line">    // 没有错误消息抛出</div><div class="line">&#125; catch &#123;</div><div class="line">    // 有一个错误消息抛出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个do语句创建了一个新的包含作用域,使得错误能被传播到一个或多个catch从句。<br>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func makeASandwich() throws &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">    try makeASandwich()</div><div class="line">    eatASandwich()</div><div class="line">&#125; catch SandwichError.outOfCleanDishes &#123;</div><div class="line">    washDishes()</div><div class="line">&#125; catch SandwichError.missingIngredients(let ingredients) &#123;</div><div class="line">    buyGroceries(ingredients)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此例中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。</p>
<p>如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。</p>
<h5 id="22-断言（assertion）"><a href="#22-断言（assertion）" class="headerlink" title="22.断言（assertion）"></a>22.断言（assertion）</h5><p>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个 断言（assertion） 来结束代码运行并通过调试来找到值缺失的原因。</p>
<p>可以使用全局 assert(<em>:</em>:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let age = -3</div><div class="line">assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)</div><div class="line">// 因为 age &lt; 0，所以断言会触发</div></pre></td></tr></table></figure>
<p>如果不需要断言信息，可以省略，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(age &gt;= 0)</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。</p>
</blockquote>
<p>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是 nil，但是后面的代码运行需要一个非 nil 值。</li>
</ul>
<blockquote>
<p>注意：<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

                <hr>
                

                <ul class="pager">
                    
                    
                    <li class="next">
                        <a href="/2017/06/25/Hexo使用总结/" data-toggle="tooltip" data-placement="top"
                           title="Hexo使用总结">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift语法（语法基础）"><span class="toc-text">Swift语法（语法基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本章将会介绍"><span class="toc-text">本章将会介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Swift"><span class="toc-text">什么是Swift</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基础部分（The-Basic）"><span class="toc-text">基础部分（The Basic）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-常量和变量"><span class="toc-text">1.常量和变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-类型标注（type-annotation）"><span class="toc-text">2.类型标注（type annotation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-常量和变量的命名"><span class="toc-text">3.常量和变量的命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-输出常量和变量"><span class="toc-text">4.输出常量和变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-注释"><span class="toc-text">5.注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-分号"><span class="toc-text">6.分号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-整数"><span class="toc-text">7.整数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-浮点数"><span class="toc-text">8.浮点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-类型安全（type-safe）和类型推断（type-checks）"><span class="toc-text">9.类型安全（type safe）和类型推断（type checks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-数值型字面量"><span class="toc-text">10.数值型字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-整数转化"><span class="toc-text">11.整数转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-整数和浮点数的转换"><span class="toc-text">12.整数和浮点数的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-类型别名（type-aliases）"><span class="toc-text">13.类型别名（type aliases）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-布尔值（Bool）"><span class="toc-text">14.布尔值（Bool）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-元组（tuples）"><span class="toc-text">15.元组（tuples）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-可选类型（Optionals）"><span class="toc-text">16.可选类型（Optionals）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-nil"><span class="toc-text">17.nil</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-if语句以及强制解析"><span class="toc-text">18.if语句以及强制解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-可选绑定（optional-binding）"><span class="toc-text">19.可选绑定（optional binding）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-隐式解析可选类型（implicitly-unwrapped-optionals）"><span class="toc-text">20.隐式解析可选类型（implicitly unwrapped optionals）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-错误处理（error-handling）"><span class="toc-text">21.错误处理（error handling）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-断言（assertion）"><span class="toc-text">22.断言（assertion）</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://www.jianshu.com/u/ee0520f2d909">我的简书</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/hanqiao8866">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 寒桥 2017
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://hanqiao8866.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','undefined','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://upload.jianshu.io/users/upload_avatars/143920/c55a48a925fd.png?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/300">
</body>

</html>
